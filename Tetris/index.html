<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>俄罗斯方块</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            /* 低饱和度渐变背景，柔和不刺眼 */
            background: linear-gradient(135deg, #6b7c9f, #a78ca3, #e6d5b8);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: "Microsoft YaHei", Arial, sans-serif;
            background-attachment: fixed;
        }

        .game-container {
            position: relative;
            padding: 20px;
            /* 低饱和浅灰背景，替代纯白，更柔和 */
            background-color: #f5f5f5;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            align-items: flex-start;
        }

        #tetris {
            border: 3px solid #555555;
            /* 低饱和深灰渐变，替代纯黑，视觉更舒缓 */
            background: linear-gradient(180deg, #222222, #333333);
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }

        .game-info {
            position: static;
            width: 160px;
            padding: 15px;
            /* 低饱和浅灰背景，提升柔和度 */
            background-color: #f0f0f0;
            border: 2px solid #555555;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .game-info .info-title {
            font-size: 18px;
            font-weight: bold;
            /* 低饱和深灰文字，替代纯黑 */
            color: #444444;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 8px;
            text-align: center;
        }

        .game-info .score-item {
            font-size: 16px;
            /* 低饱和红棕，替代高饱和红色，醒目且不刺眼 */
            color: #9c4a50;
            font-weight: bold;
            text-align: center;
            padding: 8px 0;
            background-color: #fafafa;
            border-radius: 4px;
            border: 1px solid #eee;
        }

        .game-info .ops-title {
            font-size: 15px;
            font-weight: bold;
            color: #555555;
            margin-top: 8px;
        }

        .game-info .ops-item {
            font-size: 14px;
            color: #666666;
            line-height: 1.6;
        }

        .game-tips {
            position: static;
            width: 100%;
            text-align: center;
            font-size: 13px;
            /* 低饱和灰蓝文字，替代深灰 */
            color: #718096;
            /* 低饱和浅蓝背景，更柔和 */
            background-color: #f8fafc;
            border-radius: 4px;
            padding: 10px;
            margin-top: 12px;
            border: 1px solid #e2e8f0;
        }

        /* 媒体查询，适配移动端（屏幕宽度小于600px） */
        @media (max-width: 600px) {
            .game-container {
                padding: 15px;
                margin: 0 10px;
            }

            #tetris {
                width: 240px;
                height: 480px;
            }

            .game-info {
                width: 240px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="tetris" width="300" height="600"></canvas>
        <div class="game-info">
            <div class="info-title">游戏信息</div>
            <div class="score-item">分数: <span id="score">0</span></div>
            <div class="ops-title">操作说明</div>
            <!-- 关键修改：更新操作说明为WASD -->
            <div class="ops-item">A / D: 左右移动</div>
            <div class="ops-item">W: 旋转方块</div>
            <div class="ops-item">S: 加速下落</div>
        </div>
        <div class="game-tips">游戏加载完成后自动开始，一行消除得10分，方块堆满顶部则游戏结束</div>
    </div>

    <script>
        // 1. 获取Canvas上下文和基础配置
        const canvas = document.getElementById('tetris');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');

        // 方块大小（每个小格子的像素尺寸）
        const BLOCK_SIZE = 30;
        // 游戏区域尺寸（列数 x 行数）
        const COLS = 10;
        const ROWS = 20;

        // 2. 定义俄罗斯方块的形状和【低饱和度】颜色（经典7种形状，色调保留，饱和度降低）
        const TETROMINOS = {
            I: {
                shape: [
                    [0, 0, 0, 0],
                    [1, 1, 1, 1],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ],
                color: '#99e6e6' // 低饱和青色（原#00ffff）
            },
            J: {
                shape: [
                    [1, 0, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                color: '#6666cc' // 低饱和蓝色（原#0000ff）
            },
            L: {
                shape: [
                    [0, 0, 1],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                color: '#cc9966' // 低饱和橙色（原#ffa500）
            },
            O: {
                shape: [
                    [1, 1],
                    [1, 1]
                ],
                color: '#e6e699' // 低饱和黄色（原#ffff00）
            },
            S: {
                shape: [
                    [0, 1, 1],
                    [1, 1, 0],
                    [0, 0, 0]
                ],
                color: '#99cc99' // 低饱和绿色（原#00ff00）
            },
            T: {
                shape: [
                    [0, 1, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                color: '#996699' // 低饱和紫色（原#800080）
            },
            Z: {
                shape: [
                    [1, 1, 0],
                    [0, 1, 1],
                    [0, 0, 0]
                ],
                color: '#cc6666' // 低饱和红色（原#ff0000）
            }
        };

        // 3. 游戏状态初始化
        let gameBoard = []; // 游戏面板（存储已落地的方块）
        let currentTetromino = null; // 当前下落的方块
        let currentX = 0; // 当前方块的X坐标
        let currentY = 0; // 当前方块的Y坐标
        let score = 0; // 分数
        let dropInterval = 1000; // 方块下落间隔（毫秒）
        let dropTimer = null; // 下落定时器

        // 初始化游戏面板（创建一个ROWS x COLS的二维数组，初始值为0）
        function initGameBoard() {
            gameBoard = [];
            for (let y = 0; y < ROWS; y++) {
                gameBoard[y] = [];
                for (let x = 0; x < COLS; x++) {
                    gameBoard[y][x] = 0;
                }
            }
        }

        // 4. 生成随机的俄罗斯方块
        function generateRandomTetromino() {
            const keys = Object.keys(TETROMINOS);
            const randomKey = keys[Math.floor(Math.random() * keys.length)];
            const tetromino = TETROMINOS[randomKey];

            // 初始化方块的初始位置（居中、顶部）
            currentTetromino = JSON.parse(JSON.stringify(tetromino)); // 深拷贝，避免修改原数据
            currentX = Math.floor(COLS / 2) - Math.floor(currentTetromino.shape[0].length / 2);
            currentY = 0;

            // 检查是否游戏结束（新方块生成即碰撞，说明面板已满）
            if (checkCollision()) {
                clearInterval(dropTimer);
                alert(`游戏结束！你的最终分数：${score}`);
                resetGame();
            }
        }

        // 5. 绘制游戏面板（已落地的方块）
        function drawGameBoard() {
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const block = gameBoard[y][x];
                    // 绘制格子边框（低饱和灰，更柔和）
                    ctx.strokeStyle = '#555555';
                    ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                    // 如果有方块，填充对应低饱和度颜色
                    if (block) {
                        ctx.fillStyle = block;
                        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1); // 减1避免覆盖边框
                    }
                }
            }
        }

        // 6. 绘制当前下落的方块
        function drawCurrentTetromino() {
            const shape = currentTetromino.shape;
            const color = currentTetromino.color;

            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        // 计算方块在Canvas上的实际坐标
                        const actualX = (currentX + x) * BLOCK_SIZE;
                        const actualY = (currentY + y) * BLOCK_SIZE;

                        // 填充低饱和度方块颜色
                        ctx.fillStyle = color;
                        ctx.fillRect(actualX, actualY, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                        // 低饱和浅灰边框，替代纯白，更协调
                        ctx.strokeStyle = '#dddddd';
                        ctx.strokeRect(actualX, actualY, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                    }
                }
            }
        }

        // 7. 碰撞检测（判断当前方块是否超出边界或与已落地方块重叠）
        function checkCollision() {
            const shape = currentTetromino.shape;

            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const newX = currentX + x;
                        const newY = currentY + y;

                        // 检测是否超出左右边界、下边界，或与已落地方块重叠
                        if (
                            newX < 0 || // 左边界
                            newX >= COLS || // 右边界
                            newY >= ROWS || // 下边界
                            (newY >= 0 && gameBoard[newY][newX]) // 与已落地方块重叠（newY>=0避免检测顶部未落地区域）
                        ) {
                            return true; // 发生碰撞
                        }
                    }
                }
            }
            return false; // 无碰撞
        }

        // 8. 固定当前方块到游戏面板（方块落地时调用）
        function lockTetromino() {
            const shape = currentTetromino.shape;
            const color = currentTetromino.color;

            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const actualX = currentX + x;
                        const actualY = currentY + y;
                        if (actualY >= 0) { // 避免记录顶部超出面板的方块
                            gameBoard[actualY][actualX] = color;
                        }
                    }
                }
            }

            // 消除满行并更新分数
            clearFullRows();

            // 生成新的方块
            generateRandomTetromino();
        }

        // 9. 消除满行
        function clearFullRows() {
            let rowsCleared = 0;

            for (let y = ROWS - 1; y >= 0; y--) {
                // 判断当前行是否满格
                const isFullRow = gameBoard[y].every(block => block !== 0);

                if (isFullRow) {
                    // 移除当前行，并在顶部添加一行空行
                    gameBoard.splice(y, 1);
                    gameBoard.unshift(Array(COLS).fill(0));
                    // 行消除后，y需要保持不变（因为上方的行会下落一行）
                    y++;
                    // 更新消除行数和分数
                    rowsCleared++;
                }
            }

            // 计算分数（每行10分，可扩展为多行消除加分）
            score += rowsCleared * 10;
            scoreElement.textContent = score;

            // 分数更新视觉反馈（轻微闪烁，低饱和颜色更协调）
            scoreElement.style.opacity = 0.5;
            setTimeout(() => {
                scoreElement.style.opacity = 1;
            }, 200);
        }

        // 10. 旋转当前方块
        function rotateTetromino() {
            const originalShape = JSON.parse(JSON.stringify(currentTetromino.shape));
            const rows = originalShape.length;
            const cols = originalShape[0].length;

            // 初始化旋转后的形状（矩阵转置 + 反转每行）
            const rotatedShape = [];
            for (let x = 0; x < cols; x++) {
                rotatedShape[x] = [];
                for (let y = rows - 1; y >= 0; y--) {
                    rotatedShape[x][rows - 1 - y] = originalShape[y][x];
                }
            }

            // 尝试旋转（先修改形状，检测碰撞，若碰撞则恢复原形状）
            currentTetromino.shape = rotatedShape;
            if (checkCollision()) {
                currentTetromino.shape = originalShape;
            }
        }

        // 11. 方块下落
        function dropTetromino() {
            currentY++;
            // 若碰撞则回退并固定方块
            if (checkCollision()) {
                currentY--;
                lockTetromino();
            }
        }

        // 12. 游戏渲染循环
        function render() {
            // 清空Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // 绘制游戏面板和当前方块
            drawGameBoard();
            drawCurrentTetromino();
            // 继续下一帧渲染
            requestAnimationFrame(render);
        }

        // 13. 键盘事件监听（关键修改：替换为WASD操作，保持功能不变）
        function initKeyboardControls() {
            document.addEventListener('keydown', (e) => {
                // 忽略大小写，兼容用户开启大写锁定的情况
                const key = e.key.toLowerCase();
                switch (key) {
                    case 'a': // A键：左移（对应原ArrowLeft）
                        currentX--;
                        if (checkCollision()) {
                            currentX++;
                        }
                        break;
                    case 'd': // D键：右移（对应原ArrowRight）
                        currentX++;
                        if (checkCollision()) {
                            currentX--;
                        }
                        break;
                    case 's': // S键：加速下落（对应原ArrowDown）
                        dropTetromino();
                        break;
                    case 'w': // W键：旋转方块（对应原ArrowUp）
                        rotateTetromino();
                        break;
                }
            });
        }

        // 14. 重置游戏（游戏结束后调用）
        function resetGame() {
            score = 0;
            scoreElement.textContent = score;
            initGameBoard();
            generateRandomTetromino();
            // 重启下落定时器
            clearInterval(dropTimer);
            dropTimer = setInterval(dropTetromino, dropInterval);
        }

        // 15. 初始化并启动游戏
        function startGame() {
            initGameBoard();
            initKeyboardControls();
            generateRandomTetromino();
            // 启动方块自动下落定时器
            dropTimer = setInterval(dropTetromino, dropInterval);
            // 启动渲染循环
            render();
        }

        // 页面加载完成后启动游戏
        window.onload = startGame;
    </script>
</body>
</html>